<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2025 Racing Schedules</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Clarity Analytics -->
  <script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "q5g6pdi6gf");
  </script>

  <!-- Bootstrap CSS CDN -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <!-- Custom CSS -->
  <link href="src/styles/main.css" rel="stylesheet">
  <!-- ICS.js Library -->
  <script src="https://cdn.jsdelivr.net/npm/ics-js@0.10.2/dist/ics.min.js"></script>
</head>
<body>
  <div class="container my-4">
    <!-- Header with Theme Toggle -->
    <header class="site-header d-flex justify-content-between align-items-center">
      <h1 class="text-center">2025 Racing Schedules</h1>
      <button id="themeToggle" class="btn btn-secondary" aria-label="Toggle Dark Mode">
        <i class="fas" id="themeIcon"></i>
      </button>
    </header>
    <!-- Quick Navigation Buttons -->
    <nav class="my-3">
      <div class="btn-group me-2">
        <a href="index.html" class="btn btn-primary">
          <i class="fas fa-home me-1"></i> Home
        </a>
        <a href="results.html" class="btn btn-outline-primary">
          <i class="fas fa-trophy me-1"></i> Results
        </a>
      </div>
      <div class="btn-group">
        <a href="#schedule" class="btn btn-outline-primary">
          <i class="fas fa-list me-1"></i> Full Schedule
        </a>
        <a href="#news" class="btn btn-outline-primary">
          <i class="fas fa-newspaper me-1"></i> News
        </a>
      </div>
    </nav>

    <!-- Upcoming Event Section -->
    <div id="upcoming-event" class="upcoming-event">
      <div class="row">
        <div class="col-12">
          <h4 class="mb-3"><i class="fas fa-flag-checkered me-2"></i>This Weekend's Races</h4>
          <div id="upcomingEventDetails" class="upcoming-events-list"></div>
        </div>
      </div>
    </div>

    <!-- Schedule Section -->
    <section id="schedule" class="schedule-section">
      <h2>2025 Race Schedule</h2>
      
      <!-- Global Search -->
      <div class="search-container">
        <input type="text" id="searchInput" class="search-input" placeholder="Search events...">
        <i class="fas fa-search search-icon"></i>
      </div>

      <!-- Past Races Toggle -->
      <div class="mb-3">
        <button id="showPastRaces" class="show-past-races">
          Show Past Races
        </button>
      </div>

      <!-- Schedule Tabs -->
      <ul class="nav nav-tabs" id="scheduleTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#all">All Series</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" data-bs-toggle="tab" data-bs-target="#f1">F1</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" data-bs-toggle="tab" data-bs-target="#indycar">IndyCar</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" data-bs-toggle="tab" data-bs-target="#nascar">NASCAR</button>
        </li>
      </ul>

      <!-- Add Calendar Button -->
      <div class="calendar-buttons mt-3 mb-3">
        <button class="btn btn-primary" type="button" id="downloadICSBtn">
          <i class="fas fa-calendar-plus me-1"></i> Download Calendar
        </button>
      </div>

      <div class="tab-content" id="scheduleTabContent">
        <!-- Combined Schedule -->
        <div class="tab-pane fade show active" id="all" role="tabpanel">
          <table class="table table-hover schedule-table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Series</th>
                <th>Race</th>
                <th>Venue</th>
                <th>Time</th>
                <th>Network</th>
              </tr>
            </thead>
            <tbody id="combined-schedule"></tbody>
          </table>
        </div>

        <!-- F1 Schedule -->
        <div class="tab-pane fade" id="f1" role="tabpanel">
          <table class="table table-hover schedule-table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Race</th>
                <th>Circuit</th>
                <th>Time</th>
                <th>Network</th>
              </tr>
            </thead>
            <tbody id="f1-schedule"></tbody>
          </table>
        </div>

        <!-- IndyCar Schedule -->
        <div class="tab-pane fade" id="indycar" role="tabpanel">
          <table class="table table-hover schedule-table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Race</th>
                <th>Venue</th>
                <th>Time</th>
                <th>Network</th>
              </tr>
            </thead>
            <tbody id="indy-schedule"></tbody>
          </table>
        </div>

        <!-- NASCAR Schedule -->
        <div class="tab-pane fade" id="nascar" role="tabpanel">
          <table class="table table-hover schedule-table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Race</th>
                <th>Venue</th>
                <th>Time</th>
                <th>Network</th>
              </tr>
            </thead>
            <tbody id="nascar-schedule"></tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- News Section -->
    <section id="news" class="mt-5">
      <h2>Latest News</h2>
      <div id="newsGrid" class="row g-4 mt-3"></div>
    </section>
  </div>

  <!-- Event Detail Modal (includes weather forecast functionality) -->
  <div class="modal fade" id="eventDetailModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="modalTitle">Event Details</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="event-details">
            <div class="series-badge mb-3" id="modalEventSeries"></div>
            <h5 class="mb-3" id="modalEventRace"></h5>
            <div class="row g-3">
              <div class="col-md-6">
                <div class="event-info-group">
                  <p><strong>Date & Time</strong></p>
                  <p class="mb-1"><i class="fas fa-calendar me-2"></i><span id="modalEventDate"></span></p>
                  <p class="mb-1"><i class="fas fa-clock me-2"></i><span id="modalEventTime"></span></p>
                  <p class="mb-3"><i class="fas fa-tv me-2"></i><span id="modalEventNetwork"></span></p>
                </div>
                <div class="event-info-group">
                  <p><strong>Track Information</strong></p>
                  <p class="mb-1"><i class="fas fa-map-marker-alt me-2"></i><span id="modalEventLocation"></span></p>
                  <p class="mb-1"><i class="fas fa-city me-2"></i><span id="modalEventCity"></span></p>
                </div>
              </div>
              <div class="col-md-6">
                <p><strong>Time Until Race</strong></p>
                <div id="modalCountdown" class="countdown-timer mb-3"></div>
              </div>
            </div>
          </div>
          
          <!-- Weather Section -->
          <div id="weatherSection" class="mt-4">
            <button id="fetchWeatherBtn" class="btn btn-info btn-sm">
              Show Weather Forecast
            </button>
            <div id="weatherResult" class="mt-2"></div>
          </div>
          
          <!-- Social Share -->
          <div id="socialShare" class="mt-4">
            <h6>Share this event</h6>
            <div class="d-flex gap-2">
              <a href="#" id="shareTwitter" class="btn btn-sm btn-outline-primary">
                Share on X
              </a>
            </div>
          </div>

          <!-- Calendar Integration -->
          <div id="calendarIntegration" class="mt-4">
            <h6>Add to Calendar</h6>
            <div class="d-flex gap-2">
              <button class="btn btn-primary" type="button" id="modalDownloadICS">
                <i class="fas fa-calendar-plus me-1"></i> Download Calendar
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap Bundle with Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <!-- Application Script -->
  <script type="module">
    // Import your data from data.js
    import { scheduleData, resultsData, parseEventDate, enhanceEventData, convertUTCtoLocal } from './src/js/data.js';
    import { downloadICS, downloadSeriesICS } from './src/js/calendar.js';

    /*******************************
     * Helper Functions
     *******************************/
    
    function clearCountdown(elementId) {
      const element = document.getElementById(elementId);
      if (element) {
        element.textContent = '';
        if (element.countdownInterval) {
          clearInterval(element.countdownInterval);
          element.countdownInterval = null;
        }
      }
    }
    
    function startCountdown(elementId, startTime) {
      clearCountdown(elementId);
      const countdownElement = document.getElementById(elementId);
      
      const updateCountdown = () => {
        const now = new Date().getTime();
        const distance = startTime - now;
        
        if (distance < 0) {
          clearCountdown(elementId);
          countdownElement.textContent = 'Event Started';
          return;
        }
        
        // Calculate time units
        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        
        // Format the display
        const parts = [];
        if (days > 0) parts.push(`${days}d`);
        if (hours > 0 || days > 0) parts.push(`${hours}h`);
        if (minutes > 0 || hours > 0 || days > 0) parts.push(`${minutes}m`);
        parts.push(`${seconds}s`);
        
        countdownElement.textContent = parts.join(' ');
      };
      
      updateCountdown();
      countdownElement.countdownInterval = setInterval(updateCountdown, 1000);
    }
    
    function populateTable(tableBodyId, events, columns) {
      const tbody = document.getElementById(tableBodyId);
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      
      events.forEach(event => {
        const tr = document.createElement("tr");
        const eventStartDate = parseEventDate(event.date);
        tr.setAttribute("data-start", eventStartDate.toISOString());
        
        // Check if the race is completed
        if (Date.now() >= eventStartDate.getTime() + 24 * 60 * 60 * 1000) {
          tr.classList.add("completed-race");
          
          // Find race results
          let results = [];
          if (event.series === "F1") {
            const raceName = event.race.replace(" GP", "");
            const result = resultsData.f1Past.results.find(r => 
              r.grandPrix.toLowerCase().includes(raceName.toLowerCase()) ||
              raceName.toLowerCase().includes(r.grandPrix.toLowerCase())
            );
            if (result) results.push(result);
          } else if (event.series === "IndyCar") {
            const result = resultsData.indyPast.results.find(r => 
              r.race.toLowerCase().includes(event.race.toLowerCase()) ||
              event.race.toLowerCase().includes(r.race.toLowerCase())
            );
            if (result) results.push(result);
          } else if (event.series.includes("NASCAR")) {
            if (event.race.includes("Duel")) {
              results = resultsData.nascarPast.results.filter(r => 
                r.race.toLowerCase().includes("duel")
              );
            } else {
              const eventShortName = event.race.split(" at ")[0].toLowerCase();
              const result = resultsData.nascarPast.results.find(r => 
                r.race.toLowerCase().includes(eventShortName) ||
                eventShortName.includes(r.race.toLowerCase())
              );
              if (result) results.push(result);
            }
          }
          
          // Create cells with podium information
          columns.forEach(col => {
            const td = document.createElement("td");
            if (col === "time") {
              td.textContent = event.time_utc ? convertUTCtoLocal(event.date, event.time_utc) : "";
            } else if (col === "network") {
              td.textContent = event.network || "";
            } else if (col === "venue") {
              td.textContent = event.circuit || event.venue;
            } else {
              td.textContent = event[col];
            }
            
            // Add podium information to the race name cell
            if (col === "race" && results.length > 0) {
              const podiumDiv = document.createElement("div");
              podiumDiv.className = "podium-results";
              
              const podiumHTML = results.map(result => {
                let resultTitle = results.length > 1 ? `<strong>${result.race}:</strong><br>` : "";
                return `
                  ${resultTitle}
                  <span><span class="podium-position">1st:</span> ${result.winner}</span>
                  <span><span class="podium-position">2nd:</span> ${result.second}</span>
                  <span><span class="podium-position">3rd:</span> ${result.third}</span>
                `;
              }).join('<hr class="podium-divider">');
              
              podiumDiv.innerHTML = podiumHTML;
              td.appendChild(podiumDiv);
            }
            
            tr.appendChild(td);
          });
        } else {
          // Regular event without results
          columns.forEach(col => {
            const td = document.createElement("td");
            if (col === "time") {
              td.textContent = event.time_utc ? convertUTCtoLocal(event.date, event.time_utc) : "";
            } else if (col === "network") {
              td.textContent = event.network || "";
            } else if (col === "venue") {
              td.textContent = event.circuit || event.venue;
            } else {
              td.textContent = event[col];
            }
            tr.appendChild(td);
          });
        }
        
        tr.addEventListener("click", () => openEventModal(event));
        tbody.appendChild(tr);
      });
    }
    
    function celsiusToFahrenheit(celsius) {
      return Math.round((celsius * 9/5) + 32);
    }

    // Add temperature conversion helper function
    function fahrenheitToCelsius(fahrenheit) {
      return Math.round((fahrenheit - 32) * 5 / 9);
    }

    async function fetchWeather(event, containerId) {
      const weatherContainer = document.getElementById(containerId);
      if (!weatherContainer) return;

      if (!event.latitude || !event.longitude) {
        weatherContainer.innerHTML = "<p class='text-muted'>Weather data not available for this location.</p>";
        return;
      }

      try {
        weatherContainer.innerHTML = `
          <div class="weather-loading">
            <div class="spinner-border spinner-border-sm text-primary" role="status">
              <span class="visually-hidden">Loading weather data...</span>
            </div>
            <span class="ms-2">Loading forecast...</span>
          </div>
        `;

        // Required headers for the NWS API
        const headers = {
          "User-Agent": "(RacingCentral, info@racecentral.info)",
          "Accept": "application/geo+json"
        };

        // Retrieve metadata from the NWS API
        const pointResponse = await fetch(`https://api.weather.gov/points/${event.latitude},${event.longitude}`, { headers });
        if (!pointResponse.ok) {
          throw new Error(`Error fetching location metadata: ${pointResponse.status}`);
        }
        const pointData = await pointResponse.json();
        const forecastURL = pointData.properties && pointData.properties.forecast;
        const hourlyForecastURL = pointData.properties && pointData.properties.forecastHourly;
        
        if (!forecastURL || !hourlyForecastURL) {
          throw new Error("Forecast URL not available.");
        }

        // Fetch both regular and hourly forecast data
        const [forecastResponse, hourlyResponse] = await Promise.all([
          fetch(forecastURL, { headers }),
          fetch(hourlyForecastURL, { headers })
        ]);

        if (!forecastResponse.ok || !hourlyResponse.ok) {
          throw new Error(`Error fetching forecast data`);
        }

        const [forecastData, hourlyData] = await Promise.all([
          forecastResponse.json(),
          hourlyResponse.json()
        ]);

        const periods = forecastData.properties && forecastData.properties.periods;
        const hourlyPeriods = hourlyData.properties && hourlyData.properties.periods;

        if (!periods || periods.length === 0 || !hourlyPeriods || hourlyPeriods.length === 0) {
          weatherContainer.innerHTML = "<p class='text-muted'>Forecast not available.</p>";
          return;
        }

        // Adjust eventDate using event.time_utc if available
        let eventDate = new Date(event.start);
        if (event.time_utc) {
          const [hours, minutes] = event.time_utc.split(":");
          eventDate.setUTCHours(parseInt(hours), parseInt(minutes), 0, 0);
        }

        // Find matching forecast period
        let forecastPeriod = periods.find(period => {
          const periodStart = new Date(period.startTime);
          const periodEnd = new Date(period.endTime);
          return eventDate >= periodStart && eventDate < periodEnd;
        });

        // Fallback: If no exact period is found, choose the closest period
        if (!forecastPeriod) {
          forecastPeriod = periods.reduce((prev, cur) => {
            return Math.abs(new Date(cur.startTime) - eventDate) < Math.abs(new Date(prev.startTime) - eventDate) ? cur : prev;
          });
        }

        if (forecastPeriod) {
          const tempF = forecastPeriod.temperature;
          const tempC = fahrenheitToCelsius(tempF);
          const wind = forecastPeriod.windSpeed;
          const windDir = forecastPeriod.windDirection;
          const shortForecast = forecastPeriod.shortForecast;
          
          // Get hourly forecasts around event time (3 hours before and after)
          const eventTime = eventDate.getTime();
          const relevantHourlyForecasts = hourlyPeriods.filter(period => {
            const periodTime = new Date(period.startTime).getTime();
            return Math.abs(periodTime - eventTime) <= 3 * 60 * 60 * 1000; // 3 hours before/after
          });

          // Weather icons mapping based on forecast text
          const weatherIcons = {
            'sunny': '☀️',
            'clear': '☀️',
            'mostly clear': '🌤️',
            'partly cloudy': '⛅',
            'mostly cloudy': '🌥️',
            'cloudy': '☁️',
            'rain': '🌧️',
            'showers': '🌧️',
            'thunderstorm': '⛈️',
            'snow': '🌨️',
            'fog': '🌫️'
          };

          // Find appropriate weather icon
          let weatherIcon = '☀️'; // default
          const forecast = shortForecast.toLowerCase();
          for (const [condition, icon] of Object.entries(weatherIcons)) {
            if (forecast.includes(condition)) {
              weatherIcon = icon;
              break;
            }
          }

          // Create the main weather card
          const mainWeatherCard = `
            <div class="weather-card">
              <h6 class="mb-3">Race Day Forecast</h6>
              <div class="d-flex align-items-center mb-3">
                <div class="weather-icon me-3">
                  <span style="font-size: 2.5rem;">${weatherIcon}</span>
                </div>
                <div>
                  <div class="temperature-display">
                    <span class="temp-main" style="font-size: 1.5rem;">${tempF}°F / ${tempC}°C</span>
                  </div>
                  <div class="conditions-text">${shortForecast}</div>
                </div>
              </div>
              <p class="mb-2"><strong>Wind:</strong> ${wind} ${windDir}</p>
              
              <div class="hourly-forecast mt-4">
                <h6 class="mb-3">Hourly Forecast</h6>
                <div class="hourly-breakdown d-flex overflow-auto">
                  ${relevantHourlyForecasts.map(hour => {
                    const hourTemp = hour.temperature;
                    const hourTempC = fahrenheitToCelsius(hourTemp);
                    const time = new Date(hour.startTime).toLocaleTimeString([], {hour: 'numeric'});
                    let hourIcon = '☀️';
                    const hourForecast = hour.shortForecast.toLowerCase();
                    for (const [condition, icon] of Object.entries(weatherIcons)) {
                      if (hourForecast.includes(condition)) {
                        hourIcon = icon;
                        break;
                      }
                    }
                    return `
                      <div class="hour-item text-center me-4">
                        <div class="time mb-1">${time}</div>
                        <div class="icon mb-1" style="font-size: 1.5rem;">${hourIcon}</div>
                        <div class="temp">${hourTemp}°F</div>
                        <div class="temp-c">${hourTempC}°C</div>
                      </div>
                    `;
                  }).join('')}
                </div>
              </div>
            </div>
          `;

          weatherContainer.innerHTML = mainWeatherCard;
        } else {
          weatherContainer.innerHTML = "<p class='text-muted'>Forecast not yet available for race day.</p>";
        }

      } catch (error) {
        weatherContainer.innerHTML = "<p class='text-danger'>Weather forecast not available.</p>";
        console.error("Error fetching weather:", error);
      }
    }
    
    function openEventModal(event) {
      const modal = new bootstrap.Modal(document.getElementById("eventDetailModal"));
      
      // Update modal content
      document.getElementById("modalEventSeries").textContent = event.series;
      document.getElementById("modalEventRace").textContent = event.race;
      document.getElementById("modalEventDate").textContent = event.date;
      document.getElementById("modalEventLocation").textContent = event.circuit || event.venue || "TBA";
      document.getElementById("modalEventTime").textContent = event.time_utc ? 
        convertUTCtoLocal(event.date, event.time_utc) : "TBA";
      document.getElementById("modalEventNetwork").textContent = event.network || "";
      document.getElementById("modalEventCity").textContent = event.city || "TBA";
      
      // Start countdown
      // Create event start time in UTC
      const [hours, minutes] = (event.time_utc || "00:00").split(":");
      const eventDate = new Date(event.start);
      eventDate.setUTCHours(parseInt(hours), parseInt(minutes), 0, 0);
      startCountdown("modalCountdown", eventDate.getTime());
      
      // Setup weather button
      document.getElementById("fetchWeatherBtn").onclick = () => {
        fetchWeather(event, "weatherResult");
      };
      
      // Update share link
      const shareText = `Check out the ${event.race} on ${event.date}! #Motorsports`;
      document.getElementById("shareTwitter").href = 
        `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}`;
      
      modal.show();
    }
    
    function displayUpcomingEvent() {
      const allEvents = enhanceEventData();
      allEvents.sort((a, b) => a.start - b.start);
      const now = new Date();
      const nowUTC = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));

      // Find today's events using UTC comparison
      const todaysEvents = allEvents.filter(event => {
        return event.start.getTime() === nowUTC.getTime();
      });

      // Get weekend range in UTC (Friday 00:00 UTC to Sunday 23:59:59 UTC)
      const dayOfWeekUTC = now.getUTCDay();
      const daysUntilFriday = (5 - dayOfWeekUTC + 7) % 7;
      const fridayUTC = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + daysUntilFriday));
      const sundayUTC = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + daysUntilFriday + 2, 23, 59, 59, 999));

      const weekendEvents = allEvents.filter(event => {
        return event.start >= fridayUTC && event.start <= sundayUTC;
      });

      const nextEvent = allEvents.find(event => {
        return event.start > now;
      });

      const upcomingDiv = document.getElementById("upcomingEventDetails");
      
      async function createEventCard(event) {
        const location = event.circuit || event.venue || "TBA";
        const timeString = event.time_utc ? 
          `<p class="card-text mb-1"><strong>Time:</strong> ${convertUTCtoLocal(event.date, event.time_utc)}</p>` : "";
        const countdownId = `countdown-${event.series.replace(/\s+/g, '-').toLowerCase()}`;
        const weatherId = `weather-${countdownId}`;
        
        // Create event start time in UTC
        const [hours, minutes] = (event.time_utc || "00:00").split(":");
        const eventDate = new Date(event.start);
        eventDate.setUTCHours(parseInt(hours), parseInt(minutes), 0, 0);
        
        const cardHTML = `
          <div class="card upcoming-event-item mb-3">
            <div class="card-body">
              <div class="series-badge mb-2">${event.series}</div>
              <h5 class="card-title mb-2">${event.race}</h5>
              <p class="card-text mb-1"><strong>Date:</strong> ${event.date}</p>
              <p class="card-text mb-1"><strong>Location:</strong> ${location}</p>
              ${timeString}
              <div id="${weatherId}" class="weather-section mt-3 mb-3"></div>
              <div id="${countdownId}" class="countdown-timer"></div>
            </div>
          </div>
        `;
        
        // Start the countdown after insertion
        setTimeout(() => {
          startCountdown(countdownId, eventDate.getTime());
          fetchWeather(event, weatherId);
        }, 0);
        
        return cardHTML;
      }

      const displayEvents = async (events) => {
        if (events.length > 0) {
          const cardsHTML = await Promise.all(events.map(event => createEventCard(event)));
          upcomingDiv.innerHTML = cardsHTML.join('');
        } else {
          upcomingDiv.innerHTML = "<p>No upcoming events scheduled.</p>";
        }
      };

      if (todaysEvents.length > 0) {
        displayEvents(todaysEvents);
      } else if (weekendEvents.length > 0) {
        displayEvents(weekendEvents);
      } else if (nextEvent) {
        displayEvents([nextEvent]);
      } else {
        upcomingDiv.innerHTML = "<p>No upcoming events scheduled.</p>";
      }
    }
    
    async function fetchNews() {
      const f1Feed = "https://www.motorsport.com/rss/f1/news/";
      const indyFeed = "https://www.motorsport.com/rss/indycar/news/";
      const nascarFeed = "https://www.motorsport.com/rss/nascar-cup/news/";
      try {
        const [f1News, indyNews, nascarNews] = await Promise.all([
          fetchRSS(f1Feed),
          fetchRSS(indyFeed),
          fetchRSS(nascarFeed)
        ]);
    
        const newsGrid = document.getElementById("newsGrid");
        newsGrid.innerHTML = `
          <div class="col-md-4">
            <div class="card news-card h-100">
              <div class="card-body">
                <h5 class="card-title news-title">F1 News</h5>
                ${f1News.map(item => `
                  <div class="news-item mb-3">
                    <a href="${item.link}" target="_blank" class="news-link">${item.title}</a>
                    <p class="news-date"><small>${new Date(item.pubDate).toLocaleDateString()}</small></p>
                  </div>
                `).join('')}
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="card news-card h-100">
              <div class="card-body">
                <h5 class="card-title news-title">IndyCar News</h5>
                ${indyNews.map(item => `
                  <div class="news-item mb-3">
                    <a href="${item.link}" target="_blank" class="news-link">${item.title}</a>
                    <p class="news-date"><small>${new Date(item.pubDate).toLocaleDateString()}</small></p>
                  </div>
                `).join('')}
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="card news-card h-100">
              <div class="card-body">
                <h5 class="card-title news-title">NASCAR News</h5>
                ${nascarNews.map(item => `
                  <div class="news-item mb-3">
                    <a href="${item.link}" target="_blank" class="news-link">${item.title}</a>
                    <p class="news-date"><small>${new Date(item.pubDate).toLocaleDateString()}</small></p>
                  </div>
                `).join('')}
              </div>
            </div>
          </div>
        `;
      } catch (error) {
        document.getElementById("newsGrid").innerHTML = "<p class='text-danger'>Unable to fetch news.</p>";
        console.error("Error fetching news:", error);
      }
    }
    
    async function fetchRSS(url) {
      try {
        const rss2jsonAPI = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(url)}`;
        const response = await fetch(rss2jsonAPI);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (data.status !== 'ok') {
          throw new Error('Failed to fetch RSS feed');
        }
        return data.items.slice(0, 5).map(item => ({
          title: item.title || "",
          link: item.link || "#",
          pubDate: item.pubDate || ""
        }));
      } catch (error) {
        console.error('Error fetching RSS:', error);
        return [];
      }
    }
    
    // Updated showPastRacesBtn event listener block
    const showPastRacesBtn = document.getElementById('showPastRaces');
    let pastRacesVisible = true;
    showPastRacesBtn.addEventListener('click', function() {
      pastRacesVisible = !pastRacesVisible;
      this.textContent = pastRacesVisible ? 'Hide Past Races' : 'Show Past Races';
      
      const tables = document.querySelectorAll('.schedule-table');
      tables.forEach(table => {
        const rows = table.querySelectorAll('tr[data-date]');
        rows.forEach(row => {
          const eventDate = new Date(row.getAttribute('data-date'));
          if (Date.now() >= eventDate.getTime() + 24 * 60 * 60 * 1000) {
            row.style.display = pastRacesVisible ? 'table-row' : 'none';
          } else {
            row.style.display = '';
          }
        });
      });
    });

    // Function to create a table row for an event
    function createTableRow(event, includeSeriesBadge = false) {
      const row = document.createElement('tr');
      row.setAttribute('data-date', event.start.toISOString());
      const localTime = convertUTCtoLocal(event.date, event.time_utc);
      const nowRow = new Date();
      const todayUTC = new Date(Date.UTC(nowRow.getUTCFullYear(), nowRow.getUTCMonth(), nowRow.getUTCDate()));
      if (event.start < todayUTC) {
        row.classList.add('completed-race');
      }

      // Create series badge if needed
      let seriesBadgeHTML = '';
      if (includeSeriesBadge) {
        seriesBadgeHTML = `<div class="series-badge" data-series="${event.displaySeries}">${event.displaySeries}</div>`;
      }

      // Find race results for completed races
      let podiumHTML = '';
      if (event.start < nowRow) {
        let results = [];
        if (event.series === "F1") {
          const raceName = event.race.replace(" GP", "");
          const result = resultsData.f1Past.results.find(r => 
            r.grandPrix.toLowerCase().includes(raceName.toLowerCase()) ||
            raceName.toLowerCase().includes(r.grandPrix.toLowerCase())
          );
          if (result) results.push(result);
        } else if (event.series === "IndyCar") {
          const result = resultsData.indyPast.results.find(r => 
            r.race.toLowerCase().includes(event.race.toLowerCase()) ||
            event.race.toLowerCase().includes(r.race.toLowerCase())
          );
          if (result) results.push(result);
        } else if (event.series.includes("NASCAR")) {
          if (event.race.includes("Duel")) {
            results = resultsData.nascarPast.results.filter(r => 
              r.race.toLowerCase().includes("duel")
            );
          } else {
            const eventShortName = event.race.split(" at ")[0].toLowerCase();
            const result = resultsData.nascarPast.results.find(r => 
              r.race.toLowerCase().includes(eventShortName) ||
              eventShortName.includes(r.race.toLowerCase())
            );
            if (result) results.push(result);
          }
        }

        if (results.length > 0) {
          podiumHTML = '<div class="podium-results">' +
            results.map(result => {
              let resultTitle = results.length > 1 ? `<strong>${result.race}:</strong><br>` : "";
              return `
                ${resultTitle}
                <span><span class="podium-position">1st:</span> ${result.winner}</span>
                <span><span class="podium-position">2nd:</span> ${result.second}</span>
                <span><span class="podium-position">3rd:</span> ${result.third}</span>
              `;
            }).join('<hr class="podium-divider">') +
            '</div>';
        }
      }

      // Create row content
      const cells = includeSeriesBadge ? [
        event.date,
        seriesBadgeHTML,
        `${event.race}${podiumHTML}`,
        event.circuit || event.venue,
        localTime || event.time,
        event.network || ''
      ] : [
        event.date,
        `${event.race}${podiumHTML}`,
        event.circuit || event.venue,
        localTime || event.time,
        event.network || ''
      ];

      row.innerHTML = cells.map(cell => `<td>${cell}</td>`).join('');
      row.addEventListener('click', () => openEventModal(event));
      
      return row;
    }

    // Function to populate schedule tables
    function populateSchedules() {
      const f1Table = document.getElementById('f1-schedule');
      const indyTable = document.getElementById('indy-schedule');
      const nascarTable = document.getElementById('nascar-schedule');
      const combinedTable = document.getElementById('combined-schedule');

      // Clear existing content
      [f1Table, indyTable, nascarTable, combinedTable].forEach(table => {
        if (table) table.innerHTML = '';
      });

      // Populate F1 schedule
      scheduleData.f1Events.forEach(event => {
        if (f1Table) f1Table.appendChild(createTableRow(event));
      });

      // Populate IndyCar schedule
      scheduleData.indyEvents.forEach(event => {
        if (indyTable) indyTable.appendChild(createTableRow(event));
      });

      // Populate NASCAR schedule (both regular and playoff events)
      const allNascarEvents = [...scheduleData.nascarRegularEvents, ...scheduleData.nascarPlayoffEvents];
      allNascarEvents.forEach(event => {
        if (nascarTable) nascarTable.appendChild(createTableRow(event));
      });

      // Populate combined schedule with series badges
      const allEvents = enhanceEventData();
      allEvents.sort((a, b) => a.start - b.start);
      allEvents.forEach(event => {
        if (combinedTable) combinedTable.appendChild(createTableRow(event, true));
      });

      // Set initial state of past races visibility
      showPastRacesBtn.click(); // This will hide past races initially
    }
    
    // Update search functionality to be more modern
    function setupSearch() {
      const searchInput = document.getElementById("searchInput");
      const searchContainer = searchInput.parentElement;
      searchContainer.className = "search-container";
      
      // Add search icon
      const searchIcon = document.createElement("i");
      searchIcon.className = "search-icon fas fa-search";
      searchContainer.insertBefore(searchIcon, searchInput);
      
      // Add debounced search
      let searchTimeout;
      searchInput.addEventListener("input", function(e) {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          const searchTerm = e.target.value.toLowerCase();
          const activeTab = document.querySelector(".tab-pane.active");
          
          activeTab.querySelectorAll("tbody tr").forEach(row => {
            // Store original cell HTML if not already stored
            row.querySelectorAll("td").forEach(cell => {
              if (!cell.dataset.original) {
                cell.dataset.original = cell.innerHTML;
              }
            });

            if (searchTerm === "") {
              // Restore original content
              row.querySelectorAll("td").forEach(cell => {
                cell.innerHTML = cell.dataset.original;
              });
              // Re-apply past races filter if needed
              if (row.classList.contains("completed-race") && !pastRacesVisible) {
                row.style.display = "none";
              } else {
                row.style.display = "";
              }
            } else {
              const text = row.textContent.toLowerCase();
              if (text.includes(searchTerm)) {
                row.style.display = "";
                row.querySelectorAll("td").forEach(cell => {
                  const originalHTML = cell.dataset.original;
                  cell.innerHTML = originalHTML.replace(
                    new RegExp(searchTerm, "gi"),
                    match => `<mark>${match}</mark>`
                  );
                });
              } else {
                row.style.display = "none";
              }
            }
          });
        }, 200);
      });
    }
    
    function setupThemeToggle() {
      const themeToggle = document.getElementById("themeToggle");
      const themeIcon = document.getElementById("themeIcon");
      
      function updateToggleIcon() {
        if (document.body.classList.contains("dark-mode")) {
          themeIcon.textContent = "☀️"; // Sun icon in dark mode
        } else {
          themeIcon.textContent = "🌙"; // Moon icon in light mode
        }
      }
      
      // Check for stored preference first
      const storedTheme = localStorage.getItem("theme");
      if (storedTheme) {
        document.body.classList.toggle("dark-mode", storedTheme === "dark");
      } else {
        // If no stored preference, use system preference
        const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        document.body.classList.toggle("dark-mode", prefersDark);
      }
      
      updateToggleIcon();
      
      // Listen for system theme changes
      window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (e) => {
        // Only apply system preference if user hasn't set their own preference
        if (!localStorage.getItem("theme")) {
          document.body.classList.toggle("dark-mode", e.matches);
          updateToggleIcon();
        }
      });
      
      // Handle manual toggle
      themeToggle.addEventListener("click", () => {
        document.body.classList.toggle("dark-mode");
        localStorage.setItem("theme", document.body.classList.contains("dark-mode") ? "dark" : "light");
        updateToggleIcon();
      });
    }
    
    document.addEventListener("DOMContentLoaded", () => {
      setupThemeToggle();
      setupSearch();
      populateSchedules();
      displayUpcomingEvent();
      fetchNews();
    });

    // Function to get current active tab events
    function getCurrentTabEvents() {
      const activeTabId = document.querySelector('.tab-pane.active').id;
      switch (activeTabId) {
        case 'f1':
          return scheduleData.f1Events;
        case 'indycar':
          return scheduleData.indyEvents;
        case 'nascar':
          return [...scheduleData.nascarRegularEvents, ...scheduleData.nascarPlayoffEvents];
        case 'all':
          return enhanceEventData();
        default:
          return [];
      }
    }

    // Function to get series name from active tab
    function getActiveSeriesName() {
      const activeTabId = document.querySelector('.tab-pane.active').id;
      switch (activeTabId) {
        case 'f1':
          return 'F1';
        case 'indycar':
          return 'IndyCar';
        case 'nascar':
          return 'NASCAR';
        case 'all':
          return 'All-Series';
        default:
          return '';
      }
    }

    // Add event listener for calendar button
    document.getElementById('downloadICSBtn').addEventListener('click', () => {
      const events = getCurrentTabEvents();
      const seriesName = getActiveSeriesName();
      if (events && events.length > 0) {
        const totalEvents = events.length;
        const message = `Downloading ${totalEvents} ${seriesName} events as an ICS file.\n\n` +
                       `You can import this file into any calendar application.`;
        alert(message);
        downloadSeriesICS(events, seriesName);
      }
    });

    // Update calendar button text based on active tab
    document.querySelectorAll('[data-bs-toggle="tab"]').forEach(tab => {
      tab.addEventListener('shown.bs.tab', () => {
        const seriesName = getActiveSeriesName();
        const buttonText = seriesName === 'All-Series' ? 'Download Calendar' : `Download ${seriesName} Calendar`;
        document.getElementById('downloadICSBtn').innerHTML = `<i class="fas fa-calendar-plus me-1"></i> ${buttonText}`;
      });
    });

    // Store the current event when opening the modal
    const eventDetailModal = document.getElementById('eventDetailModal');
    eventDetailModal.addEventListener('show.bs.modal', (event) => {
      const button = event.relatedTarget;
      const eventData = JSON.parse(button.getAttribute('data-event'));
      eventDetailModal.currentEvent = eventData;
    });

    // Add event listener for modal download button
    document.getElementById('modalDownloadICS').addEventListener('click', () => {
      const event = eventDetailModal.currentEvent;
      if (event) {
        downloadICS(event);
      }
    });
  </script>
</body>
</html>